"""
Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
SPDX-License-Identifier: MIT-0

update_attachments.py
Python lambda script to update our alarms with any new attachments. This script relies on environment variables to pass in how
things should be configured. These are normally set by the CloudFormation template wrapping this script. Those variables are:

STACK_ARN - The CloudFormation stack ARN used for this deployment
TGW_ID - The Transit Gateway ID to monitor
METRIC_NAMES - Comma-separated list of metrics to alarm on. ex: "BytesIn,BytesOut"
STDDEV - By how many standard deviations should the anomaly detection threshold be set to, ex: "2"
MINUTES - How many minutes should the anomalies be occurring for before we alarm and start the capturing?, ex: "2"
MINIMUM_VALUE - At very low usages, the standard deviation alarm will trigger on very low amounts. This parameter defines how many bytes per minute an 
                attachment must have before we consider triggering on the detection threshold.
SNS_TOPIC - The SNS topic ARN to send notifications to
LAMBDA_REF - The lambda ARN of the alarm handling function

Additionally, it leverages some variables set by AWS Lambda itself - AWS_LAMBDA_FUNCTION_NAME and AWS_REGION.
"""
import boto3
import logging
import os


def set_alarm(tgwa_id: str, metric: str):
    logging.info(f'Setting alarm on attachment {tgwa_id} metric {metric}')
    cw = boto3.client('cloudwatch')
    tags_list=[{'Key': 'stack-arn', 'Value': os.environ['STACK_ARN']}, {'Key': 'attachment-id', 'Value': tgwa_id}, {'Key': 'metric', 'Value': metric}]

    # This format is made such that humans can understand the alarm easily in console view, although it makes
    # the scripting a bit harder by not having a consistent prefix.
    stack_id = os.environ['STACK_ARN'].split('/')[2]
    alarm_name = f'{metric}-{tgwa_id}-Alarm-{stack_id}'

    met = cw.put_metric_alarm(AlarmName=alarm_name,
                              AlarmDescription=f'Anomaly detection alarm generated by lambda {os.environ['AWS_LAMBDA_FUNCTION_NAME']} from {os.environ['STACK_ARN']}',
                              OKActions=[os.environ['LAMBDA_REF']], AlarmActions=[os.environ['LAMBDA_REF']],
                              Metrics=[{'Id': 'm1',
                                        'MetricStat': {'Metric': {'Namespace': 'AWS/TransitGateway', 'MetricName': metric, 'Dimensions': [{'Name': 'TransitGateway', 'Value': os.environ['TGW_ID']}, {'Name': 'TransitGatewayAttachment', 'Value': tgwa_id}]},
                                                       'Period': 60, 'Stat': 'Average'}, 'ReturnData': False},
                                        {'Id': 'e1', 'Expression': f'ANOMALY_DETECTION_BAND(m1, {os.environ['STDDEV']})', 'Label': 'Anomaly Band', 'ReturnData': False},
                                        {'Id': 'e2', 'Expression': f'IF(m1>{os.environ['MINIMUM_VALUE']} AND m1>MAX(e1),1,0)', 'Label': 'Alarm Trigger', 'ReturnData': True}],
                              Threshold=0, ComparisonOperator='GreaterThanThreshold', EvaluationPeriods=int(os.environ['MINUTES']), DatapointsToAlarm=int(os.environ['MINUTES']), Tags=tags_list)
    print(f"Added an alarm to attachment ID {tgwa_id} metric {metric}.")    


def clear_alarm(tgwa_id: str, metric: str):
    cw = boto3.client('cloudwatch')
    stack_id = os.environ['STACK_ARN'].split('/')[2]
    alarm_name = f'{metric}-{tgwa_id}-Alarm-{stack_id}'
    cw.set_alarm_state(AlarmName=alarm_name, StateValue='OK', StateReason="Alarm is being removed.")
    cw.delete_alarms(AlarmNames=[alarm_name])    
    print(f"Deleted alarm {alarm_name}.")


def handler(event, context):
    try:
        ec2 = boto3.client('ec2')
        sns = boto3.client('sns')
        cw = boto3.client('cloudwatch')

        # Get current alarms by looking for our lambda as the action
        current_alarms = {}
        paginator = cw.get_paginator('describe_alarms')
        resp = paginator.paginate(AlarmTypes=['MetricAlarm'], ActionPrefix=os.environ['LAMBDA_REF'])
        for page in resp:
            for alarm in page['MetricAlarms']:
                if 'Metrics' in alarm:
                    # This is one of ours. Get the metric and attachment this alarm is monitoring, and mark it done already.
                    for metric in alarm['Metrics']:
                        # Metrics will have the actual statistics we're monitoring (MetricStat) or may be a math function
                        # which won't have that field, so make sure we check for that.
                        if 'MetricStat' in metric:
                            tgwa_id = None
                            for dim in metric['MetricStat']['Metric']['Dimensions']:
                                if dim['Name'] == 'TransitGatewayAttachment':
                                    tgwa_id = dim['Value']
                            if tgwa_id not in current_alarms:
                                current_alarms[tgwa_id] = {}
                            # We set this to False for now, as we haven't verified this attachment still exists yet.
                            # The loop below will set this to True for attachments we find. At the end, we go through 
                            # this dict and any alarms that still exist but their attachments don't will get deleted.
                            current_alarms[tgwa_id][metric['MetricStat']['Metric']['MetricName']] = False

        # Find all current attachments, and make sure alarms are set
        results = {'Added': 0, 'Deleted': 0}
        paginator = ec2.get_paginator('describe_transit_gateway_attachments')
        resp = paginator.paginate(Filters=[{'Name': 'transit-gateway-id', 'Values': [os.environ['TGW_ID']]}])
        for page in resp:
            for attachment in page['TransitGatewayAttachments']:
                tgwa_id = attachment['TransitGatewayAttachmentId']
                if tgwa_id not in current_alarms:
                    current_alarms[tgwa_id] = {}
                for metric in os.environ['METRIC_NAMES'].split(','):
                    if (tgwa_id not in current_alarms) or (metric not in current_alarms[tgwa_id]):
                        set_alarm(tgwa_id, metric)
                        results['Added'] += 1
                        current_alarms[tgwa_id][metric] = True
                    elif (tgwa_id in current_alarms and metric in current_alarms[tgwa_id]):
                        current_alarms[tgwa_id][metric] = True
        
        # See if we have any alarms lingering around for attachments that we didn't find.  If so, delete them.
        for tgwa_id, metrics in current_alarms.items():
            for metric, found in metrics.items():
                if not found:
                    clear_alarm(tgwa_id, metric)
                    results['Deleted'] += 1

    except Exception as e:
        logging.error('Exception: %s' % e, exc_info=True)
        logging.error(f"Data from request:\nevent={event}\ncontext={context}")

        # This next line could error again on us, but CFN has already been responded to, so this is a 'best-effort'
        # type call.
        sns = boto3.client('sns')
        sns.publish(TopicArn=os.environ['SNS_TOPIC'], Subject=f'Lambda {os.environ['AWS_LAMBDA_FUNCTION_NAME']} in {os.environ['AWS_REGION']} had an exception.',
                    Message=f'The lambda function {os.environ['AWS_LAMBDA_FUNCTION_NAME']} in {os.environ['AWS_REGION']} had an exception.\n\n'
                    f'Exception: {e}\n\n'
                    f'Event data: {event}')
        raise e
